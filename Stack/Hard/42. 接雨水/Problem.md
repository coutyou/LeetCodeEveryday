# 42. 接雨水

## 题目

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

## 示例

**示例 1：**

> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出：6
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
>

**示例 2：**

> 输入：height = [4,2,0,3,2,5]
> 输出：9

## 提示

* `n == height.length`
* `0 <= n <= 3 * 10^4`
* `0 <= height[i] <= 10^5`

## 解题思路

有两种思路，一种是将雨水区域竖着切割，进行累积，另一种是将雨水区域横着切割，进行累积。

在第一种方法中，关键的地方是要找到每一个元素在左右两边的子数组中最大的元素（包括该元素），然后取较小的那个，与该元素相减，结果就是雨水的高度。而如何快速得到每个位置左右两个子数组中的最大值，可以分别从两个方向遍历数组，并维护两个最大值数组。但是注意到，最后的结果只与两个最大值中较小的那个有关，并且当从左到右或者从右到左遍历时，左/右子数组的最大值是可以在遍历的过程中维护的，利用这个对称性，可以用两个指针，分别从左右两边进行遍历，并且分别维护最大值。左最大值相对左指针而言是左边的最大值，相对右指针而言却是左边的部分值的最大值。右最大值同理。当左最大值小于右最大值时，可以知道左指针的左子数组最大值，一定小于左指针的右子数组最大值，又因为最后的结果只与两个最大值中较小的那个有关，所以左指针对应的雨水高度只与左最大值有关，此时两者相减，然后左指针右移，更新左最大值。因为对称性，右指针同理。通过指针的方法，空间复杂度O(n)变为O(1)。从这里关键的地方在于找的是最大值中的最小值，同时又有子数组的最大值小于等于数组的最大值的性质，此外还有对称性。

在第二个方法中，则是需要不断找到数组中类似“谷”的三元组，然后用雨水将其填满。这个操作可以维护一个单调不增的单调栈来完成。

最后用了第一种方法，时间复杂度为O(n)，空间复杂度为O(1)。

## 性能

执行用时：48 ms, 在所有 Python3 提交中击败了64.85%的用户

内存消耗：14.9 MB, 在所有 Python3 提交中击败了90.58%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/trapping-rain-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。