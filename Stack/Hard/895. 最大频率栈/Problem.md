# 895. 最大频率栈

## 题目

实现 FreqStack，模拟类似栈的数据结构的操作的一个类。

FreqStack 有两个函数：

push(int x)，将整数 x 推入栈中。
pop()，它移除并返回栈中出现最频繁的元素。
如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。



## 示例

**示例 1：**

> 输入：
> ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
> [[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
> 输出：[null,null,null,null,null,null,null,5,7,5,4]
> 解释：
> 执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：
>
> pop() -> 返回 5，因为 5 是出现频率最高的。
> 栈变成 [5,7,5,7,4]。
>
> pop() -> 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。
> 栈变成 [5,7,5,4]。
>
> pop() -> 返回 5 。
> 栈变成 [5,7,4]。
>
> pop() -> 返回 4 。
> 栈变成 [5,7]。

## 提示

* 对 `FreqStack.push(int x)` 的调用中 `0 <= x <= 10^9`
* 如果栈的元素数目为零，则保证不会调用 `FreqStack.pop()`。
* 单个测试样例中，对 `FreqStack.push` 的总调用次数不会超过 `10000`。
* 单个测试样例中，对 `FreqStack.pop` 的总调用次数不会超过 `10000`。
* 所有测试样例中，对 `FreqStack.push` 和 `FreqStack.pop` 的总调用次数不会超过 `150000`。

## 解题思路

本题的解法很巧妙，我也是看了官方的解法才做出来的。

需要两个映射，一个映射是从数字到频率的映射，另一个映射是从频率到数字集合的映射，其中第二个映射的结果应该是一个栈，这样才能方便得到最近到达该频率的数字，也即离栈顶最近的数字。另外，还需要维护一个最大频率。

只能说这是用大量空间来换时间的算法，用哈希表来快速得到某一个数字的频率以及某一个频率对应的数字。最坏情况下，如果push大量频率相同的数字，空间开销会很大。

时间复杂度为O(1)，空间复杂度为O(n)。

## 性能

执行用时：276 ms, 在所有 Python3 提交中击败了95.95%的用户

内存消耗：22.1 MB, 在所有 Python3 提交中击败了90.54%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-frequency-stack
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。