# 145. 二叉树的后序遍历

## 题目

给定一个二叉树的根节点 `root` ，返回它的 **后序** 遍历。

## 示例

**示例 1：**

> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
> 
> 输出: [3,2,1]

## 进阶

递归算法很简单，你可以通过迭代算法完成吗？

## 解题思路

递归算法比较简单，而迭代算法可以通过用栈模拟来完成。

一种取巧的方法是，类似前序遍历，将中-右-左的遍历结果进行倒序。

而如果想沿用中序和前序遍历的思路，在其基础上进行修改，单纯地修改代码的顺序显然是不行的，因为在处理完左子树后，需要切换到右子树，最后才能将中间节点加入结果。因此，需要额外的空间进行标记，当右子树处理完后，通过这个标记，直接将中间节点添加到结果中。

标记的方法很多，一种方法是在出栈节点有右子树时，再次将当前节点入栈，并入栈一个特殊值，如None，然后切换到右子树。另一种方法是记录上一次的root指针，如果当前出栈的节点的右子树为上一次的root指针，说明右子树处理结束，将当前节点加入结果中。

时间复杂度为O(n)，空间复杂度为O(n)。

同样地，存在**Morris**算法，能将空间复杂度降到O(1)。其核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。详见https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/

## 性能

执行用时：36 ms, 在所有 Python3 提交中击败了81.54%的用户

内存消耗：15 MB, 在所有 Python3 提交中击败了5.24%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。