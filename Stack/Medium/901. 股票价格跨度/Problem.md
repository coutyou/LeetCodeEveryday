# 901. 股票价格跨度

## 题目

编写一个 `StockSpanner`类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是` [100, 80, 60, 70, 60, 75, 85]`，那么股票跨度将是` [1, 1, 1, 2, 1, 4, 6]`。

## 示例

**示例 1：**

> 输入：["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
> 输出：[null,1,1,1,2,1,4,6]
> 解释：
> 首先，初始化 S = StockSpanner()，然后：
> S.next(100) 被调用并返回 1，
> S.next(80) 被调用并返回 1，
> S.next(60) 被调用并返回 1，
> S.next(70) 被调用并返回 2，
> S.next(60) 被调用并返回 1，
> S.next(75) 被调用并返回 4，
> S.next(85) 被调用并返回 6。
>
> 注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
> (包括今天的价格 75) 小于或等于今天的价格。

## 提示

* 调用` StockSpanner.next(int price) `时，将有 `1 <= price <= 10^5`。
* 每个测试用例最多可以调用 `10000` 次 `StockSpanner.next`。
* 在所有测试用例中，最多调用 `150000` 次 `StockSpanner.next`。
* 此问题的总时间限制减少了 50%。

## 解题思路

观察示例可以知道，如果前一个元素小于或等于当前元素，那么可以将前一个结果加到当前结果中，这样的累加可以迭代地往前进行，假如遇到比前一个元素更大但是比当前元素更小的元素，容易知道累加没有重叠。但是比如说遇到前前一个元素比前一个元素小，那么累加的部分就会产生重复，为了避免这种情况发生，可以维护一个单调递减栈和一个结果栈，每次调用next函数时，初始化res为1，然后根据单调栈进行出栈，并累加结果栈。直到栈空或者遇到更大的元素，则结束，将当前元素和对应的结果入栈。

时间复杂度为O(n)，空间复杂度为O(n)。

## 性能

执行用时：508 ms, 在所有 Python3 提交中击败了28.72%的用户

内存消耗：19.1 MB, 在所有 Python3 提交中击败了95.30%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/online-stock-span
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。