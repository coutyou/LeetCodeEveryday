# 1124. 表现良好的最长时间段

## 题目

给你一份工作时间表 `hours`，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于` 8 `小时的时候，那么这一天就是**「劳累的一天」**。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格**大于**「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

## 示例

**示例 1：**

> 输入：hours = [9,9,6,0,6,6,9]
> 输出：3
> 解释：最长的表现良好时间段是 [9,9,6]。

## 提示

* `1 <= hours.length <= 10000`
* `0 <= hours[i] <= 16`

## 解题思路

把大于8看作+1，把小于等于8看作-1，那么题目等价于求最长的连续区间，使得区间和大于0。

如果维护一个前缀和的数组presum，那么就等价于求一个max(j-i)，其中j>i，presum[j]>presum[i]。

presum中最小的元素min为锚，那么答案最少是最右边的元素到min这段区间的长度，而想要找更长的结果，就需要找min左边更大的元素。

那么应该选择min左边的哪些元素呢？参考min的选择，我们应该选择这样的元素num，使得num左边的元素都大于num，否则完全可以选择num左边小于等于num的元素作为区间左端点，这样的区间一定更长。而presum[0]因为左边没有元素所以一定可以选择，因此，最后选择的这些备选的左端点，是从presum[0]到min之间的前缀最小值。而对于右端点，则可以从最右边开始反向遍历，但我们不需要每次都逐个与备选左端点进行对比，因为如果我们想产生比上一个区间长度更长的结果，因为右端点左移了，那么左端点也必须比上个左端点左移，也就是说之前对比过的左端点就不需要再对比了。因此，我们可以将备选左端点从左到右放入一个栈中，让右端点遍历时不断对比并出栈，在这个过程中维护最长的区间长度。

时间复杂度为O(n)，空间复杂度为O(n)。

## 性能

执行用时：232 ms, 在所有 Python3 提交中击败了70.75%的用户

内存消耗：15.5 MB, 在所有 Python3 提交中击败了69.56%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-well-performing-interval
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。