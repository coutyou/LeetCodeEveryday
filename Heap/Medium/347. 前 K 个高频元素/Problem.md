# 347. 前 K 个高频元素

## 题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

## 示例

**示例 1：**

> 输入: nums = [1,1,1,2,2,3], k = 2
> 输出: [1,2]

**示例 2：**

> 输入: nums = [1], k = 1
> 输出: [1]

## 提示

* `1 <= nums.length <= 10^5`
* `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
* 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

## 进阶

你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

## 解题思路

从895. 最大频率栈获得启发，遍历数组的同时用哈希表维护两个映射——数字到频率、频率到数字，同时维护一个最大频率。

遍历结束后，从大频率到小频率将数字加入结果中，但是会存在重复的元素，虽然可以用set去重，但是这些重复的元素会导致多余的时间浪费。

所以为了避免这些重复，可以遍历两次，第一次得到数字到频率的映射，第二次得到频率到数字的映射。

时间复杂度为O(n)，空间复杂度为O(n)。

## 性能

执行用时：48 ms, 在所有 Python3 提交中击败了78.44%的用户

内存消耗：17.4 MB, 在所有 Python3 提交中击败了92.54%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/top-k-frequent-elements/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。