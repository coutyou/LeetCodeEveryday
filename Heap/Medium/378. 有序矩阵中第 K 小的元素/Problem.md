# 378. 有序矩阵中第 K 小的元素

## 题目

给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第` k `小的元素。
请注意，它是**排序后**的第 `k` 小元素，而不是第 `k` 个 不同 的元素。

## 示例

**示例 1：**

> 输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
> 输出：13
> 解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13

**示例 2：**

> 输入：matrix = [[-5]], k = 1
> 输出：-5

## 提示

* `n == matrix.length`
* `n == matrix[i].length`
* `1 <= n <= 300`
* `-10^9 <= matrix[i][j] <= 10^9`
* 题目数据 **保证** `matrix` 中的所有行和列都按 **非递减顺序** 排列
* `1 <= k <= n^2`

## 解题思路

一种思路是类似373. 查找和最小的K对数字，每次将下边和右边的元素作为candidate入最小堆，弹出k次后得到结果。时间复杂度为O(k)，空间复杂度为O(k)，但因为k在0到$n^2$之间，所以平均时间复杂度为O($n^2$)，空间复杂度为O($n^2$)。

另一种思路是k路归并，时间复杂度为O(klogn)，空间复杂度为O(n)。这种方法只利用了一个方向上的有序性，所以效率还能提高。

还有一种思路是二分查找，属于典型的题了。一个关键点是如何判断某个数组在矩阵中的序号，可以通过统计矩阵中小于等于该数的数有多少个，从矩阵左下角开始，向上移动到第一个小于等于该数的位置，累加每一列这样的位置的行号，该操作的时间复杂度为O(n)。另一个关键点是如何进行二分，如果二分后要判断是否在矩阵中，开销太大，索性让答案通过二分逐渐收敛到答案即可。因为可能答案对应的数字有多个，导致小于等于答案的数字个数大于k，所以这种情况要保留为右边界。还有一种情况是，可能遇到大于答案，小于比答案更大的数但是不在矩阵中的情况，此时统计结果与答案一样，因此要往左边界收敛，所以计算中点时用地板除。

时间复杂度为O(nlog(matrix\[n-1\]\[n-1\]-matrix\[0\]\[0\]))，空间复杂度为O(1)。

## 性能

执行用时：48 ms, 在所有 Python3 提交中击败了78.44%的用户

内存消耗：17.4 MB, 在所有 Python3 提交中击败了92.54%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。