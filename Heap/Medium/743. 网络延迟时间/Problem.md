# 743. 网络延迟时间

## 题目

有` n `个网络节点，标记为 `1` 到` n`。

给你一个列表 `times`，表示信号经过**有向**边的传递时间。 `times[i] = (ui, vi, wi)`，其中` ui` 是源节点，`vi` 是目标节点， `wi `是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K `发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

## 示例

**示例 1：**

> 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
> 输出：2

**示例 2：**

> 输入：times = [[1,2,1]], n = 2, k = 1
> 输出：1

**示例 3：**

>输入：times = [[1,2,1]], n = 2, k = 2
>输出：-1

## 提示

* `1 <= k <= n <= 100`
* `1 <= times.length <= 6000`
* `times[i].length == 3`
* `1 <= ui, vi <= n`
* `ui != vi`
* `0 <= wi <= 100`
* 所有 `(ui, vi)` 对都 **互不相同**（即，不含重复边）

## 解题思路

单源最短路径且边的值非负，可以用Dijkstra+堆优化解决。

维护一个小顶堆，堆中是目前所有的可达但未确定最短路径长度的节点和对应的备选的长度，每次取出堆顶，那么对应的可达节点的最短路径就是该长度。当该可达节点的最短路径长度确定后，堆中还存在一些应该被淘汰的路径长度，但是删除比较麻烦，可以用一个哈希表记录该节点是否已经确定长度，弹出时判断然后跳过即可。在堆顶节点的路径长度确定后，还要将其能到达的下一步节点，且是未确定长度的节点，以及对应的路径长度入堆。

这里一个关键的逻辑——为什么堆顶的一定是最短路径？换句话说，有没有可能最短路径没有在堆里？因为我们是从源节点出发，由近及远进行遍历，如果存在到达堆中某个节点的某个路径不在堆内，就说明该路径中目标节点的上一个节点的最短路径还没确定。要么“上一个节点”在堆中，要么“上一个节点”不在堆中，此时“上一个节点”的上一个节点也可以再次类推...也就是说路径中必有一个非源节点在堆中，而该节点到目标节点的路径长度和一定非负，所以仔细思考就可以知道，即使是在最好的情况下，这条路径的总长度也就等于堆的堆顶的长度。也就是说，如果存在到达堆中某个节点的某个路径不在堆内，那么其长度一定大于等于最短路径的长度。

时间复杂度为O(ElogE)，空间复杂度为O(E+n)，E为图的边数，也即times的大小。

## 性能

执行用时：88 ms, 在所有 Python3 提交中击败了86.31%的用户

内存消耗：16 MB, 在所有 Python3 提交中击败了97.00%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/network-delay-time
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

