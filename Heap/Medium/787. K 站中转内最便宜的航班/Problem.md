# 787. K 站中转内最便宜的航班

## 题目

有 `n` 个城市通过 `m` 个航班连接。每个航班都从城市 `u` 开始，以价格 `w` 抵达 `v`。

现在给定所有的城市和航班，以及出发城市 `src` 和目的地 `dst`，你的任务是找到从 `src `到 `dst `最多经过 `k` 站中转的最便宜的价格。 如果没有这样的路线，则输出 `-1`。

## 示例

**示例 1：**

> 输入: 
> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
> src = 0, dst = 2, k = 1
> 输出: 200
>

**示例 2：**

> 输入: 
> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
> src = 0, dst = 2, k = 0
> 输出: 500
>

## 提示

* `n` 范围是 `[1, 100]`，城市标签从 `0` 到 `n - 1`
* 航班数量范围是 `[0, n * (n - 1) / 2]`
* 每个航班的格式 `(src, dst, price)`
* 每个航班的价格范围是 `[1, 10000]`
* `k` 范围是 `[0, n - 1]`
* 航班没有重复，且不存在自环

## 解题思路

单源最短路径问题，可以用Dijkstra+最小堆的算法解决，但注意到特殊点在于最多n次中转，这样Dijkstra的递归条件就不成立了，因为当前节点在n次中转内的最小路径≠min(前一个节点在n次中转内的最小路径+前一个节点到当前节点的路径值)，而是当前节点在n次中转内的最小路径=min(前一个节点在n-1次中转内的最小路径+前一个节点到当前节点的路径值)，这样就要用到递归。这样的算法相当于将dst节点开始的k步之内的路径都枚举了一遍，最坏的情况下时间复杂度太高。又或者不维护seen和dist，但这样也相当于将dst节点开始的k步之内的路径都枚举了一遍。

可以用Bellman-Ford，但可以不用进行V-1次松弛，只需进行k+1次。这个算法可以用矩阵动态规划完成，又因为当前状态只与上一步状态有关，所以可以优化为一维数组完成，还可以优化为队列完成，因为在队列中省略掉了一些在数组中进行遍历到的无效次数。

时间复杂度为O(n\*k)，空间复杂度为O(n)。

## 性能

执行用时：52 ms, 在所有 Python3 提交中击败了93.76%的用户

内存消耗：15.6 MB, 在所有 Python3 提交中击败了49.37%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cheapest-flights-within-k-stops
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。