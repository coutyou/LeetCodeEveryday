# 313. 超级丑数

## 题目

编写一段程序来查找第 `n` 个超级丑数。

超级丑数是指其所有质因数都是长度为 `k` 的质数列表 `primes` 中的正整数。

## 示例

**示例 1：**

> 输入: n = 12, primes = [2,7,13,19]
> 输出: 32 
> 解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。

## 提示

* `1 `是任何给定 `primes `的超级丑数。
*  给定 `primes` 中的数字以升序排列。
* 0 < `k` ≤ 100, 0 < `n` ≤ 106, 0 < `primes[i]` < 1000 。
* 第 `n` 个超级丑数确保在 32 位有符整数范围内。

## 解题思路

本题可以看作是264. 丑数 II的扩展，正如之前的分析一样，如果还是维护一个小顶堆，将会导致len(primes)-1倍的时间和空间的浪费，所以可以考虑用动态规划+k指针(k = len(primes))。

但是用动态规划时，每次都需要找到k个指针对应值中的最小值，而每次只移动一个指针，也就是说绝大部分元素都是重复的，所以可以考虑维护一个小顶堆，用空间换时间，额外空间大小为k，而时间从n\*k变成了n\*logk。此外还需要对入堆的元素进行查重，用set，空间大小为n+k。指针移动的时间约为n*k。

时间复杂度为O(n*k)，空间复杂度为O(n+k)。

## 性能

执行用时：172 ms, 在所有 Python3 提交中击败了98.89%的用户

内存消耗：26.3 MB, 在所有 Python3 提交中击败了26.06%的用户

## 声明

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/super-ugly-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。